# -*- coding: utf-8 -*-
"""OptimalPlayer.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1NwAL9gbXXE_S1V95yRoE9kR3tSbQIxMO
"""

from pypokerengine.players import BasePokerPlayer
from pypokerengine.utils.card_utils import estimate_hole_card_win_rate, gen_cards
from pypokerengine.utils.game_state_utils import restore_game_state
from pypokerengine.engine.hand_evaluator import HandEvaluator
from time import sleep
import time
import pprint
import array
import operator
import random
import math

# track opponent's behaviour, assume opponent balanced / logical at the start
opp_behaviour = {}
opp_behaviour['passive'] = 0
opp_behaviour['aggressive'] = 0
opp_behaviour['balanced'] = 1

# randomly initialise weights w1 and w2 for eval function
# values are floats between 0 and 1
w1 = 0.7 #random.random()
w2 = 0.3 #random.random()
w3 = 0.5
win_prob = 0
round_ctr = 1
opp_raise_threshold = 100
counter = 0

win_rate_history = []
ob_fn_history = []
ob_fn = 0.5
hand_strength_history = []
opp_hand_win_rate = 0.5

#the thresholds you will definitely raise and fold
raise_threshold = 0.60
fold_threshold = 0.23
game_count = 0


class Group26Player(BasePokerPlayer):
    

  def declare_action(self, valid_actions, hole_card, round_state):
    #start = time.time()
    preflop_corr = 0.3163266
    flop_corr = 0.66611347
    turn_corr = 0.79630204
    river_corr = 1.0
    
    global ob_fn
    # how much you multiply to your current OHS when your opponent raises
    # should change according to opponent behaviour
    river_multiplier = 1.15 + 0.65 * ob_fn
    preflop_multiplier = 1.0 + (river_multiplier - 1.0)*preflop_corr
    turn_multiplier = 1.0 + (river_multiplier - 1.0)*turn_corr
    flop_multiplier = 1.0 + (river_multiplier - 1.0)*flop_corr
    # how much you multiply to your current OHS when your opponent calls 
    # should change according to opponent behaviour
    river_call_multiplier = 0.8+0.2*ob_fn
    preflop_call_multiplier = 1.0 + (river_call_multiplier - 1.0)*preflop_corr
    turn_call_multiplier = 1.0 + (river_call_multiplier - 1.0)*turn_corr
    flop_call_multiplier = 1.0 + (river_call_multiplier - 1.0)*flop_corr
    
    # estimate opponent hand win rate based on their past actions
    street = round_state['street']
    if street == 'preflop':
        multiplier = preflop_multiplier
        call_multiplier = preflop_call_multiplier
    elif street == 'flop':
        multiplier = flop_multiplier
        call_multiplier = flop_call_multiplier
    elif street == 'turn':
        multiplier = turn_multiplier
        call_multiplier = turn_call_multiplier
    elif street == 'river':
        multiplier = river_multiplier
        call_multiplier = river_call_multiplier
    
    global opp_hand_win_rate
    round_info  = round_state['action_histories'][street]
    opp_actions = [ i for i in round_info if i['uuid']!=self.uuid]
    self_actions = [ i for i in round_info if i['uuid'] ==self.uuid]
    
    if street == 'preflop':
        if len(self_actions) == 1:
            opp_hand_win_rate = 0.5
            
    if len(opp_actions)>0:
        last_opp_action = opp_actions[-1]
        if last_opp_action['action'] == 'CALL':
            opp_hand_win_rate = opp_hand_win_rate * locals()[street+'_call_multiplier']
            if opp_hand_win_rate > 0.80:
                opp_hand_win_rate = 0.80
        if last_opp_action['action'] == 'RAISE':
            opp_hand_win_rate = opp_hand_win_rate * locals()[street+'_multiplier']

            if opp_hand_win_rate < 0.40:
                opp_hand_win_rate = 0.40

    

    # win_prob is between 0 - 100
    global win_prob
    win_prob = estimate_hole_card_win_rate(100, 2, gen_cards(hole_card), gen_cards(round_state['community_card'])) 
    # print('my winprob',win_prob)
    
    #opponenet behaviour function scaled to 0-1     
    prob_passive = float(opp_behaviour['passive'])/sum(opp_behaviour.values())
    prob_agg = float(opp_behaviour['aggressive'])/sum(opp_behaviour.values())
    ob_fn = (50 + (prob_passive*50) + (-prob_agg*50))/100
     #assume all the bots in the tournament are rather logical 
    if ob_fn >0.75:
        ob_fn = 0.75
    if ob_fn < 0.25:
        ob_fn = 0.25
        
    print 'ob fn:' + str(ob_fn)

    #calculate overall win rate based on self and opponent hand strength
    overall_win_prob = win_prob * (1- opp_hand_win_rate)/(win_prob*(1- opp_hand_win_rate) + opp_hand_win_rate*(1-win_prob))
    expected_pot = 0
    can_raise = len([item for item in valid_actions if item['action'] == 'raise']) > 0
    global raise_threshold 
    if overall_win_prob < 0.5:
        pot = round_state['pot']['main']['amount']/2
        # estimate final pot
        if street == 'preflop':
            expected_pot = pot + 100
        elif street == 'flop':
            expected_pot = pot + 80
        elif street == 'turn':
            expected_pot = pot + 40
        elif street == 'river':
            expected_pot = pot + 40
        #print('expectd',expected_pot)
        #calculate breakeven point
        fold_breakeven_point = (1.0 - float(pot)/float(expected_pot))/2.0
        fold_breakeven_point = 0
        if overall_win_prob < fold_threshold:
            return 'fold'
        if(overall_win_prob < fold_breakeven_point):
            global fold_threshold
            if fold_breakeven_point==fold_threshold:
                fold_breakeven_point = fold_breakeven_point+0.01
            fold_prob = locals()[street+'_corr'] + ( fold_breakeven_point - overall_win_prob)/abs(fold_breakeven_point-fold_threshold) * (1 - locals()[street+'_corr'])
            # print('foladprob:',fold_prob)
            seed = random.uniform(0, 1)
            if seed < fold_prob:
                return 'fold'
            else:
                return 'call'
        else:
            return 'call'       
    elif overall_win_prob > raise_threshold and can_raise:
        raise_prob = locals()[street+'_corr'] + (overall_win_prob - raise_threshold)/0.05* (1 - locals()[street+'_corr'])
        #print('raise_prob', raise_prob)
        seed = random.uniform(0, 1)
        if seed < raise_prob:
            return 'raise'
        else:
            return 'call'
    else:
        return 'call'


  def receive_game_start_message(self, game_info):
    pass
    

  def receive_round_start_message(self, round_count, hole_card, seats):
    global opp_hand_win_rate
    global ob_fn
    opp_hand_win_rate = 0.5
    ob_fn = 0.5

  def receive_street_start_message(self, street, round_state):
    pass

  def receive_game_update_message(self, action, round_state):
    pass

  def receive_round_result_message(self, winners, hand_info, round_state):

    # obtain opponent uuid
    for player in round_state['seats']:
      if player['uuid'] != self.uuid:
        opp_uuid = player['uuid']
        break
    print(hand_info)
    # can see opponent's hand
    if len(hand_info) == 2:
      for user in hand_info:
        if user['uuid'] == opp_uuid:
          opp_hand = user['hand']['card']

    # obtain history of opponent actions
    opp_actions = []
    opp_flop = []
    opp_turn = []
    opp_river = []
    for turn in round_state['action_histories']:

      if not turn in round_state['action_histories']:
        return

      for actions in round_state['action_histories'][turn]:
        if actions['uuid'] == opp_uuid and not actions['action'] in ['BIGBLIND','SMALLBLIND']:
          opp_actions.append(actions['action'])
          if turn == 'flop':
            opp_flop.append(actions['action'])
          elif turn == 'turn':
            opp_turn.append(actions['action'])
          elif turn == 'river':
            opp_river.append(actions['action'])

    if len(hand_info) == 2:
      opp_win_prob_flop = estimate_hole_card_win_rate(100, 2, gen_cards(opp_hand), gen_cards(round_state['community_card'][:3])) * 100
      opp_win_prob_turn = estimate_hole_card_win_rate(100, 2, gen_cards(opp_hand), gen_cards(round_state['community_card'][:4])) * 100
      opp_win_prob_river = estimate_hole_card_win_rate(100, 2, gen_cards(opp_hand), gen_cards(round_state['community_card'])) * 100
      
      print(opp_win_prob_flop)
      print(opp_win_prob_turn)
      print(opp_win_prob_river)
      global opp_raise_threshold
      global lowerbounds
      global opp_lowerbound

      consider = []
      lowerbound = []
      
      if opp_flop != []:
        if 'RAISE' in opp_flop:
          consider.append(opp_win_prob_flop)
        elif 'CALL' in opp_flop or 'CHECK' in opp_flop:
          lowerbound.append(opp_win_prob_flop)
      if opp_turn != []:
        if 'RAISE' in opp_turn:
          consider.append(opp_win_prob_turn)
        elif 'CALL' in opp_turn or 'CHECK' in opp_turn:
          lowerbound.append(opp_win_prob_turn)
      if opp_river != []:
        if 'RAISE' in opp_river:
          consider.append(opp_win_prob_river)
        elif 'CALL' in opp_river or 'CHECK' in opp_river:
          lowerbound.append(opp_win_prob_river)
    
    num_raise = opp_actions.count('RAISE')
    num_call = opp_actions.count('CALL') + opp_actions.count('CHECK')
    num_fold = opp_actions.count('FOLD')

    try:
      percentage_raise = float(num_raise)/len(opp_actions)
      percentage_call = float(num_call)/len(opp_actions)
      percentage_fold = float(num_fold)/len(opp_actions)
    except ZeroDivisionError:
      return

    # map opponent behaviour
    global opp_behaviour

    # draw or opponent won, check if he is passive
    # if our win probability is high and he doesn't raise, likely passive
    if len(winners) == 2 or winners[0]['uuid'] == opp_uuid:
        if win_prob > 0.6 and percentage_raise < 0.4:
            opp_behaviour['passive'] += (2*win_prob)

    # draw or we won, check if he is aggressive
    # if our win probability is low and he keeps raising, likely aggressive
    if len(winners) == 2 or winners[0]['uuid'] == self.uuid:
        if win_prob < 0.6 and percentage_raise > 0.20:
            opp_behaviour['aggressive'] += (2*(1-win_prob))


